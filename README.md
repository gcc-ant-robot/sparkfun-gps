> Note: The following documentation is contained in [the tutorial PDF](https://github.com/gcc-ant-robot/sparkfun-gps/blob/master/sparkfun-tutorial/Sparkfun-tutorial.pdf).  Check it out there!

![image](./sparkfun-tutorial/imgs/glamour.png)

Introduction
============

This guide will cover the design and implementation of a (relatively)
low-cost, high-precision localization solution using Global Positioning
System (GPS) Real-Time-Kinematics (RTK). Here is an overview of the
system:

-   The system is based on the UBLOX F9P GPS Receiver. We're using the
    Sparkfun's breakout board, called the "Sparkfun GPS-RTK 2\". This
    GPS receiver is accurate to 1-2 cm when in RTK-Fixed mode and is
    configured using the [Sparkfun Ublox Arduino
    Library](https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library).

-   The system uses LoRa radios to send RTCM data between the Base
    Station and the rover. Although untested, the Sparkfun ProRF
    breakout board has a theoretical line-of-sight range of 2
    kilometers! This module uses the RFM95 radio, which we interface
    with through the RadioHead library.

Note: on the two units which I am sending to Grove City, the LCD display
is connected to the Blackboard. This is because I didn't have my
soldering iron handy to solder these displays to the ProRF. The I2C
ports on the Blackboard are directly connected to the Qwiic bus, so the
Blackbaord is basically a "passthrough\" which physically connects the
LCD panels to the ProRF via the Qwiic bus.

Functional Overview
-------------------

This guide does not attempt to explain how RTK works. However, it is
sufficient to say that RTK localization systems consist of a bast
station, which typically does not move, and which generates correction
data which is then sent to a "rover\" GPS receiver. The Rover uses the
Base Station's correction data to refine its location solution,
typically to around 1-2 cm accuracy for RTK systems.

### Base Station

1.  The Base Station is not intended to move. When the unit is first
    powered on, the Base Station's GPS receiver is "reset\". This step
    is intended to purge any remnants from previous runs, and resets the
    GPS receiver to a known state.

2.  Next, the Base Station begins a "Survey-in\" routine. As currently
    configured, the Base Station will survey its location for at least 1
    minute, and will continue surveying until it the standard deviation
    of its own position solutions is less than 2.5 meters.

3.  Once the survey-in step is complete, the Base Station will go into
    TIME mode. In this mode, the Base Station will use its survey'ed
    location as a ground truth and will generate RTCM (GPS correction)
    messages for other GPS receivers. The messages generated by our Base
    Station are tailored to our specific application and are shown in
    Table [1](#tab:enabled-rtcm){reference-type="ref"
    reference="tab:enabled-rtcm"}[^1]

::: {#tab:enabled-rtcm}
   **RTCM Message Label**                                         **Frequency**
  ------------------------ -------------------------------------- ------------------
            1005           Stationary RTK reference station ARP   every 10 seconds
            1074           GPS MSM4                               every second
            1084           GLONASS MSM4                           every second
            1230           GLONASS code-phase                     every 5 seconds

  : These RTCM messages are generated by the Base Station.
:::

### Rover

When first powered on, the F9P unit is "hard reset\" by the ProRF in an
attempt to reset the unit to a known state. Then, the GPS receiver
immediately begins searching for a location fix. The rover will show the
fix type, the RTK status: (None, Float, or Fixed[^2]), as well as the
positional accuracy and distance from Base Station.

System Description
==================

Hardware Overview
-----------------

The hardware of this system is comprised of two (almost) identical
units: the Base Station (on black 3d printed chassis) and the Rover (on
a white chassis). Block diagrams for both units are in the appendices.
**The only physical difference** between the units is is the
ProRF-to-F9P wiring:

-   The Base Station has a UART wire going from the F9P board's `UART1`
    TX pin, to the ProRF's `Serial1` RX pin.

-   The Rover has a UART wire going from the ProRF's `Serial1` TX pin,
    to the F9P's `UART2` RX pin.

This difference aside, the two units are identical. Both units:

-   Have a "Qwiic\" connection between the ProRF and the F9P. This
    connection is used by the ProRF to configure the F9P at startup.
    This connection is **not** used to relay RTCM data from the F9P to
    the ProRF.

-   Both have UFL to SMA connectors for the ProRF and the F9P. (Note,
    that the F9P uses a different UFL to SMA connector since the SMA pin
    mating is different).

-   Both units are connected to a Sparkfun Blackboard via the Qwiic bus.
    **The Blackboard is NOT USED!**. There is no source code for the
    Blackbaord. On these units, it exists only to provide power from the
    Blackboard's DC barrel jack to the other components via the Qwiic
    bus.

Software Overview
-----------------

There are only two source files for this project: `Theo_Base.ino` and
`Theo_Rover.ino`, for the Base Station ProRF and Rover ProRF
microcontrollers respectively. I've tried to make the system robust so
that all of the system configuration, setup, and runtime happenings are
contained in these source code files. This should make the system easier
to comprehend (only one source code file per unit) and simpler to
operate (flash and go!). **Basically, everything you need software-wise
is in these two .C files!**

See the **PROJECT REPOSITORY** for all the files and resources used in
this project:\
**<https://github.com/gcc-ant-robot/sparkfun-gps>**

### Base Station Software

`Theo_Base.ino` is meant to be used on the Base Station Pro-RF module.
On startup, the ProRF will open communication lines with the F9P and its
onboard LoRa radio as seen in the configuration section of the
`Theo_Base.ino` source code file. It will reset the F9P module (clearing
out previous Base Station location solutions, etc.) and will begin the
Survey-In mode on the F9P.

Once Survey-In is complete, the ProRF begins broadcasting RTCM data, by
reading bytes of RTCM from the ProRF's `Serial1` buffer, and shuttling
that data to the LoRa radio driver instance: `rf95`.

One important thing to note is that RTCM data is "bursty\", there's alot
of data for a few milliseconds, and then there's a lull for  950 ms
until the next group of RTCM messages are generated by the F9P.
(Remember that Table [1](#tab:enabled-rtcm){reference-type="ref"
reference="tab:enabled-rtcm"} shows how often each RTCM message is
sent). In order to operate efficiently (or at all\... as I found out),
we cannot sent each RTCM byte as its own LoRa message. Thus, RTCM data
is grouped into "packets\" that are 250 Bytes long, and then each packet
is sent as a separate LoRa message.

The ProRF's `Serial1` is setup with a timeout of 100ms, so that when an
RTCM byte is received after a period of inactivity (the  950ms that the
F9P is not generating RTCM messages), the `Serial1` interface will wait
100ms for more bytes from the F9P before `Serial1.available()` becomes
TRUE. Basically, the 100ms timeout let's us say something like: "When
you get a byte from the F9P, wait 100ms for more bytes from the F9P
before you start packetizing them to send over LoRa\". This ensures that
we send complete (uncorrupted) RTCM messages over the LoRa link.

To summarize the RTCM handling portion of the code:

1.  The F9P generates RTCM messages roughly once per second. This data
    arrives at the ProRF's `Serial1` port very quickly (basically all at
    once).

2.  The `Serial1` interface waits 100ms from the time it first receives
    an RTCM byte to make sure that all the information has been
    received.

3.  The RTCM data for that second is packetized into LoRa messages that
    are 250 bytes in length.

4.  These messages are sent out over the LoRa link during the  950ms of
    inactivity which exists before the next batch of RTCM messages are
    generated by the F9P.

It is generally accepted that you should get RTCM messages from the Base
Station to the Rover within 1 second of their creation in order to get
an RTK FIXED solution at the rover.

### Rover Software

The `Theo_Rover.ino` source code file is intended to be run on the
Rover's ProRF module. Just like the Base Station, the Rover ProRF opens
communication lines to the LCD display, F9P GPS receiver, and onboard
LoRa radio. The ProRf also resets the F9P module (to get a consistent
starting point), and then starts waiting to receive RTCM messages.

The Rover's RTCM handling code shuttles data from the LoRa radio to the
ProRF's `Serial1` interface. This data is a burst of RTCM messages,
which are spread across multiple LoRa messages (or packets). In order to
piece these LoRa messages back into a burst of RTCM data, the code will
wait for `RFWAITTIME` ms (currently set to 500ms) after the first LoRa
message is received, before sending the combined messages to the Rover
F9P all at once over the ProRf's `Serial1` port.

To summarize the RTCM handling code for the Rover:

1.  When a LoRa message is first received, take the message's data and
    place it in a buffer.

2.  For the next 500 ms, take any LoRa messages which are received, and
    concatenate these to the end of the buffer from the previous step.
    (Basically, recombine the LoRa messages into a burst of RTCM data).

3.  Once the 500 ms is up, take all the data in the buffer and write it
    to the `Serial1` interface, which is connected to the F9P.

The Rover source code also has a `check_gps()` method which demonstrates
how to query the F9P for its solution and status. This method is used to
update the Rover's LCD display.

Installation Instructions
=========================

⚠ WARNING: Never power up Base Station or Rover without their LoRa and
GPS antennas! ⚠

Prerequisites
-------------

You'll want to make sure that you have the following installed:

-   Arduino IDE: <https://www.arduino.cc/en/main/software>

-   Ublox U-Center: <https://www.u-blox.com/en/product/u-center>

-   Latest F9P Firmware: See the "Firmware Update\" section here:\
    <https://www.u-blox.com/en/product/zed-f9p-module#tab-documentation-resources>\
    At the time of writing, the latest firmware is "[ZED-F9P HPG
    1.13](https://www.u-blox.com/en/ubx-viewer/view/UBX_F9_100_HPG_113_ZED_F9P.7e6e899c5597acddf2f5f2f70fdf5fbe.bin?url=https%3A%2F%2Fwww.u-blox.com%2Fsites%2Fdefault%2Ffiles%2FUBX_F9_100_HPG_113_ZED_F9P.7e6e899c5597acddf2f5f2f70fdf5fbe.bin)\".

-   ProRF Board Support: Follow the tutorial in the "Setting Up
    Arduino\" section here:\
    <https://learn.sparkfun.com/tutorials/sparkfun-samd21-pro-rf-hookup-guide?_ga=2.144736500.1907947329.1598414611-1867689729.1598414611#setting-up-arduino>

-   You'll need to install the following Arduino Libraries:

    See here for instructions on installing Arduino Libraries:\
    <https://www.arduino.cc/en/Guide/Libraries#how-to-install-a-library>

-   RadioHead Arduino Library: This webpage has a link to the library in
    ZIP form:\
    <https://www.airspayce.com/mikem/arduino/RadioHead/>

-   Ublox Arduino Library: I used Version 1.8.6 here:\
    <https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library/releases/tag/v1.8.6>

Base Station Setup
------------------

I'll now explain how to repeat the Base Station setup/installation for
yourself.

### Upgrade Firmware on Base Station F9P

1.  Begin with a Base Station that is physically assembled:

    -   The ProRF and F9P are connected via Qwiic and Serial lines.

    -   The LoRa and GPS antennas are attached.

    -   The LCD display attached to the I2C bus if desired.

    -   Blackboard, or other power-source, connected to the Qwiic bus
        for power distribution.

2.  Connect the F9P to your laptop with a USB-A to USB-C cable.

3.  Open U-Center on your laptop.

4.  Under the Receiver menu, select Connection $\rightarrow$ COM15. (You
    may see a different COM port, select whichever COM port is
    available.)

5.  You should begin to see data/text/images update in the U-Center
    window with live GPS data.

6.  Under the "Tools\" menu, select "Firmware Update\".

7.  In the "Firmware Image\" dialog box, select the firmware binary
    which you downloaded from Ublox (It should have been the only
    ".bin\" file you downloaded in the prerequisites section).

8.  Click the green "Go\" sign in the bottom left of the window to start
    the firmware update. It may take a minute or two for the update to
    complete.

9.  Once the update is complete, "Bounce\" the F9P (unplug, and replug
    it to your laptop and reconnect to U-Center as in step 3).

10. You can now unplug the F9P from your laptop.

### Program Base Station ProRF

1.  Connect the ProRF to your laptop with a micro-USB to USB-A cable.

2.  Open the Arduino IDE.

3.  In the "Tools\" Menu of the Arduino IDE, make sure that "Sparkfun
    SAMD21 ProRF\" is selected for the "Board\" option.

4.  Also in the "Tools\" Menu, make sure that you select whatever port
    your ProRF is connected to your laptop on. For me, this is
    "/dev/cu.usbmodem5998\".

5.  Open the `Theo_Base.ino` source code file, and hit the Upload arrow
    to flash this to the ProRF.

6.  Once the source code is flashed, you're done!

Rover Setup
-----------

The setup for the rover is pretty similar to the Base Station:

### Upgrade Firmware on Rover F9P

The F9P Firmware update process is identical to that of the Base
Station:

1.  Begin with a Base Station that is physically assembled:

    -   The ProRF and F9P are connected via Qwiic and Serial lines.

    -   The LoRa and GPS antennas are attached.

    -   The LCD display attached to the I2C bus if desired.

    -   Blackboard, or other power-source, connected to the Qwiic bus
        for power distribution.

2.  Connect the F9P to your laptop with a USB-A to USB-C cable.

3.  Open U-Center on your laptop.

4.  Under the Receiver menu, select Connection $\rightarrow$ COM15. (You
    may see a different COM port, select whichever COM port is
    available.)

5.  You should begin to see data/text/images update in the U-Center
    window with live GPS data.

6.  Under the "Tools\" menu, select "Firmware Update\".

7.  In the "Firmware Image\" dialog box, select the firmware binary
    which you downloaded from Ublox (It should have been the only
    ".bin\" file you downloaded in the prerequisites section).

8.  Click the green "Go\" sign in the bottom left of the window to start
    the firmware update. It may take a minute or two for the update to
    complete.

9.  Once the update is complete, "Bounce\" the F9P (unplug, and replug
    it to your laptop and reconnect to U-Center as in step 3).

10. You can now unplug the F9P from your laptop.

### Program Rover ProRF

This process is also almost identical to that of the Base Station,
EXCEPT, we will use the **`Theo_Rover.ino`** source code file.

1.  Connect the ProRF to your laptop with a micro-USB to USB-A cable.

2.  Open the Arduino IDE.

3.  In the "Tools\" Menu of the Arduino IDE, make sure that "Sparkfun
    SAMD21 ProRF\" is selected for the "Board\" option.

4.  Also in the "Tools\" Menu, make sure that you select whatever port
    your ProRF is connected to your laptop on. For me, this is
    "/dev/cu.usbmodem5998\".

5.  Open the `Theo_Rover.ino` source code file, and hit the Upload arrow
    to flash this to the ProRF.

6.  Once the source code is flashed, you're done!

Test!
=====

Go outside with your Base Station and rover. Connect a 12V battery to
the Base Station Blackboard once your've set it in a semi-permanent
location. Wait for it to "Survey-In\". Then, connect your Rover to a
battery, and see how far away your can walk before you loose your RTK
Fixed solution.

Block Diagram
=============
See the [Block Diagram Here](./sparkfun-tutorial/bdiagram.pdf)

References
==========

-   **Project Repository:** Contains the source code, 3d printer files,
    and everything else Theo used in this project:
    <https://github.com/gcc-ant-robot/sparkfun-gps>

-   Ublox F9P Integration Manual, Section 3.1.5 contains detailed
    information about what RTCM messages, Fixed vs. Float solution
    types, and more:\
    <https://www.u-blox.com/sites/default/files/ZED-F9P_IntegrationManual_%28UBX-18010802%29.pdf>

-   Ardusimple's F9P Configuration Files, show handy advice for
    delimiting RTCM data for the F9P:
    <https://www.ardusimple.com/configuration-files/>

-   Radiohead Documentation for RFM95:
    <https://www.airspayce.com/mikem/arduino/RadioHead/classRH__RF95.html#details>

Index of Terms
==============

-   "MSM4\": "MSM4\" data contains the code, phase, and carrier-to-noise
    measurements for the corresponding satellite constellation (GPS,
    Glonass, Galileo, etc\...).

-   "RTK\": Real-time-kinematics.

-   F9P: Usually refers to the Sparkfun GPS-RTK board, which uses a
    Ublox F9P GPS receiver.

-   "Glonass\": Russian GPS constellation.

-   "GPS\": Generally, this is the technology which allows us to
    triangulate our location. However, technically, this is the US/DOD
    constellation of satellites which enable this function.

[^1]: I spent some time experimenting to come up with a few messages
    that would get RTK-Fixes while minimizing the load on the LoRa
    radios. Please see [Ardusimple's Configuration
    Files](https://www.ardusimple.com/configuration-files/) for
    instructions on delimiting RTCM messages to conserve bandwidth. Also
    look at [Section 3.1.5 of the Ublox F9P integration
    manual](https://www.u-blox.com/sites/default/files/ZED-F9P_IntegrationManual_%28UBX-18010802%29.pdf)
    for information on what each message is used for.

[^2]: RTK=NONE indicates that no RTK solution is being used. This may be
    the result of a loss of radio link, or a failure on the part of the
    Base Station to provide correction data. RTK=Float means that
    correction data is being used, but there is still some uncertainty
    in the solution. RTK=Fixed is the gold standard, and usually means
    that your solution is accurate to the cm level. See the [Ublox F9P
    integration
    manual](https://www.u-blox.com/sites/default/files/ZED-F9P_IntegrationManual_%28UBX-18010802%29.pdf)
    for a much more detailed explanation.
